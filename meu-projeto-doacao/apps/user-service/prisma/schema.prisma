// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("USER_DATABASE_URL")
}

// Enums
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
  BLOCKED
}

enum DocumentType {
  CPF
  CNPJ
  PASSPORT
  OTHER
}

enum VerificationStatus {
  PENDING
  SUBMITTED
  REVIEWING
  APPROVED
  REJECTED
  EXPIRED
}

enum RoleType {
  USER
  DONOR
  FUNDRAISER
  MODERATOR
  ADMIN
}

enum WalletProvider {
  METAMASK
  WALLET_CONNECT
  COINBASE_WALLET
  TRUST_WALLET
  PHANTOM
  OTHER
}

// TODO: talvez isso n faça tanto sentido
enum BlockchainNetwork {
  ETHEREUM_MAINNET
  ETHEREUM_SEPOLIA
  POLYGON
  BSC
  ARBITRUM
  OPTIMISM
  SOLANA
  BASE
}

enum UserReputation {
  TRUSTED // Good standing, reliable
  GOOD // Generally positive behavior
  NEUTRAL // New or average user
  WARNING // Suspect behavior, caution advised
  DANGEROUS // High risk, avoid interactions
}

// TODO: onde e como administrar a questão dos documentos
// Model that represents a user in the system
model User {
  id                   String         @id @default(uuid())
  username             String         @unique
  status               UserStatus     @default(PENDING_VERIFICATION)
  reputation           UserReputation @default(NEUTRAL) @map("reputation_score")
  isAdmin              Boolean        @default(false) @map("is_admin")
  isModerator          Boolean        @default(false) @map("is_moderator")
  email                String?        @unique
  emailVerified        Boolean        @default(false) @map("email_verified")
  passwordHash         String?        @map("password_hash")
  twoFactorEnabled     Boolean        @default(false) @map("two_factor_enabled")
  twoFactorSecret      String?        @map("two_factor_secret")
  twoFactorBackupCodes String?        @map("two_factor_backup_codes")
  loginFailedAttempts  Int            @default(0) @map("login_failed_attempts")
  loginFailedLastAt    DateTime?      @map("login_failed_last_at")
  accountLockedUntil   DateTime?      @map("account_locked_until")
  createdAt            DateTime       @default(now()) @map("created_at")
  updatedAt            DateTime       @updatedAt @map("updated_at")
  lastLoginAt          DateTime?      @map("last_login_at")
  deletedAt            DateTime?      @map("deleted_at")
  // TODO: Relations

  roles   UserRole[] // One user can have multiple roles
  profile UserProfile?
  wallets UserWallet[] // One user can have multiple wallets
  audits AuditLog[]  // One user can have multiple audit logs

  @@index([status])
  @@index([id])
  @@index([reputation])
  @@index([createdAt])
  @@index([email])
  @@map("users")
}

// Model to represent user roles
model UserRole {
  id         String   @id @default(uuid())
  userID     String   @map("user_id")
  role       RoleType
  assignedAt DateTime @default(now()) @map("assigned_at")
  assignedBy String?  @map("assigned_by") // ID of the admin/moderator who assigned the role
  user       User     @relation(fields: [id], references: [id], onDelete: Cascade)

  @@unique([userID, role]) // A user cannot have the same role assigned multiple times
  @@index([userID])
  @@index([role])
  @@map("user_roles")
}

// Model to represent countries
model Country {
  code String @id @map("code") // ISO country code
  name String @map("name") // Full country name

  userProfiles UserProfile[] // Relation to UserProfile
}

// Model to represent user profiles (extended information that is publicly visible)
model UserProfile {
  id               String        @id @default(uuid())
  userID           String        @unique @map("user_id")
  avatarS3Key      String?       @map("avatar_s3_key") // S3 key for the avatar image
  avatarS3Url      String?       @map("avatar_s3_url") // Pre-signed URL for accessing the avatar image
  bio              String?       @db.Text()
  documentType     DocumentType? @map("document_type")
  countryCode      String?       @map("country_code")
  documentNumber   String?       @unique @map("document_number") @db.Text()
  totalDonated     Decimal       @default(0.0) @map("total_donated") @db.Decimal(20, 8)
  totalReceived    Decimal       @default(0.0) @map("total_received") @db.Decimal(20, 8)
  campaingsCreated Int           @default(0) @map("campaings_created")
  donationsCount   Int           @default(0) @map("donations_count")
  metaData         Json?         @map("meta_data") // Additional metadata as JSON
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")

  country Country? @relation(fields: [countryCode], references: [code])
  user    User     @relation(fields: [userID], references: [id], onDelete: Cascade)

  @@index([documentNumber])
  @@index([countryCode])
  @@map("user_profiles")
}

// Model to represent user wallets
model UserWallet {
  id                String            @id @default(uuid())
  userID            String            @map("user_id")
  walletAddress     String            @map("wallet_address")
  walletProvider    WalletProvider    @map("wallet_provider")
  blockchainNetwork BlockchainNetwork @map("blockchain_network")
  addedAt           DateTime          @default(now()) @map("added_at")

  user User @relation(fields: [userID], references: [id], onDelete: Cascade)

  @@unique([userID, walletAddress, blockchainNetwork]) // A user cannot register the same wallet address on the same blockchain multiple times
  @@index([userID])
  @@index([walletAddress])
  @@map("user_wallets")
}

// TODO: User verification table

// TODO: user session table

model AuditLog {
  id        String    @id @default(uuid())
  userID    String?   @map("user_id")
  action    String
  entity    String
  description String   @db.Text()
  metadata Json?
  ipAddress String?   @map("ip_address")
  createdAt DateTime  @default(now()) @map("created_at")

  user User? @relation(fields: [userID], references: [id], onDelete: SetNull)

  @@map("audit_logs")
  @@index([action])
  @@index([entity])
  @@index([createdAt])
}
